# Java基础笔记

本笔记基于视频，来自：[尚硅谷Java零基础全套视频教程](https://www.bilibili.com/video/BV1PY411e7J6/)



## 1. Java基础介绍

### 1.1 Java运行环境

#### 1.1.1 什么是JDK、JRE

``JDK``（Java Development Kit）是Java程序开发工具包，包含``JRE``和开发人员使用的工具。

``JRE``（Java Runtime Environment）是Java程序运行时的环境，包含``JVM``和运行时所需要的核心类库。

> JDK = JRE + 开发工具集（如Javac编译工具等）
>
> JRE = JVM + Java SE标准类库



#### 1.1.2 Java版本选择

Java 8/11/17是长期维护版本，但Java 8/11在企业中长期高占比.

> 1. Java 11在垃圾回收方面优于Java 8，所以很多开发者抛弃Java 8.
>
> 2. Springboot 3.0 后续将以Java 17为基准进行开发，故Java 17占有率会越来越高。

 

#### 1.1.3 JDK下载与安装

[Java 17 JDK下载](https://www.oracle.com/java/technologies/downloads/#jdk17-windows)



#### 1.1.4 配置环境变量

在``系统高级设置``中配置以下变量：

```shell
JAVA_HOME = D:\Study\MyJavaAll\JDK\jdk-17_windows-x64_bin\jdk-17.0.7
PATH = %JAVA_HOME%\bin
```



### 1.2 开发体验

#### 1.2.1 开发步骤

Java程序开发分为三个步骤：**编写**、**编译**、**运行**

**编写：**将Java代码编写到扩展名为``.java``的源文件中。

**编译：**通过``javac.exe``命令对该java文件进行编译，生成一个或多个字节码文件，每一个字节码文件对应一个Java类，并且字节码文件名与类名相同。

**运行：**通过``java.exe``命令对生成的``class``文件进行运行。



#### 1.2.2 HelloWorld程序声明

```java
public class test01{
    public static void main(String[] args) {
        System.out.println("hello,world!");
    }
}
```

一个源文件中可以声明多个类，但是最多只能有一个类使用``public``进行声明。且要求声明为``public``的类的类名与源文件名相同。



### 1.3 注释

#### 1.3.1 单行注释与多行注释

单行注释：

```java
// 单行注释
```

多行注释：

```java
/*
多行注释1
多行注释2
多行注释3
*/
```

（1）单行注释和多行注释中声明的信息，不参与编译。即编译之后的字节码文件中不包含单行注释和多行注释的内容。

（2）多行注释不能够嵌套使用。



#### 1.3.2 文档注释

文档注释：为Java特有

```java
/**
	@author: 指定源文件作者
	@version: 指定源文件版本
*/
```

文档注释内容可以被``JDK``提供的工具``javadoc``所解析，生成一套以网页文件形式体现的该程序的说明文档。

```shell
javadoc -d <generated_dir> -author -version <file_name>
```



### 1.4. JVM简要介绍

#### 1.4.1 Java特性

**跨平台性：**只需要在机器上安装Java虚拟机``JVM``就可以让``JVM``来负责Java程序在系统中的运行。**Write Once, Run Anywhere!**

**其他优势：**面向对象性、健壮性、安全性高、简单性、高性能...



#### 1.4.2 JVM特性

``JVM``是一个虚拟的计算机，是Java程序的运行环境。``JVM``具有指令集，并使用不同的存储区域，负责执行指令，管理数据、内存、寄存器。

**跨平台性：**

对于$m$种编译器和$n$种解释器，若没有``JVM``则需要$m*n$种编译器，有``JVM``则需要$m+n$种编译器和解释器。

**自动内存管理：**

（1）Java程序运行过程中的**数据分配**和**存储**等都由``JVM``完成。

（2）在内存空间达到阈值时，``JVM``可检查并释放可释放的存储器空间。

（3）GC的自动回收很大程度上减少了因为没有释放空间而导致的**内存泄露**。

> Java程序会出现**内存溢出**和**内存泄漏**问题吗？会。
>
> 内存泄漏是指对于已经不再使用的垃圾空间，JVM不认为它是垃圾空间，不回收利用。



## 2. 变量与运算符

### 2.1 关键字

定义：被Java赋予了特殊含义，用作专门用途的字符串或单词。

> （1）关键字全部都是**小写字母**。
>
> （2）``goto``,``const``是关键字但暂未使用。



### 2.2 标识符

定义：Java中变量、方法、类等要素命名时使用的字符串。

> 记忆技巧：凡是可以**自己起名**的，均称为标识符，如：类名、方法名。



#### 2.2.1 标识符命名规则

（1）由英文字母大小写、数字、下划线、$组成

（2）数字不可作为开头

（3）不可使用关键字和空格



#### 2.2.2 标识符命名规范

（1）包名：全小写

（2）类、接口名：每个单词首字母大写

（3）变量、方法名：除第一个单词外，每个单词首字母大写

（4）常量名：所有单词大写，并用下划线连接



### 2.3 变量

#### 2.3.1 变量基础知识

（1）变量指内存中的一个存储区域，该区域的数据可以在同一类型范围内变化

（2）变量三要素：数据类型、变量名、值



#### 2.3.2 变量类型

（1）基本数据类型（8种）：整型（byte / short / int / long）、浮点型（float / double）、字符型（char）、布尔型（boolean）

（2）引用数据类型：类（class）、数组（array）、接口（interface）、枚举（enum）、注解（annotation）、记录（record）



#### 2.3.3 变量作用域

距离变量最近的一对大括号包括了变量的作用域，变量只在作用域之内有效。



### 2.4 基本数据类型

#### 2.4.1 整型

| 类型  | 占用存储空间 | 数据范围                          |
| :---: | :----------: | --------------------------------- |
| byte  | 1byte = 8bit | $-128 \sim 127$                   |
| short |    2 byte    | $-2^{15} \sim 2^{15}-1$           |
|  int  |    4 byte    | $-2^{31} \sim 2^{31}-1$（约21亿） |
| long  |    8 byte    | $-2^{63} \sim 2^{63}-1$           |

> 【注】声明long类型变量，需要提供后缀，为大写或小写的L。



#### 2.4.2 浮点类型

|     类型      | 占用存储空间 |          数据范围           |
| :-----------: | :----------: | :-------------------------: |
| 单精度 float  |    4 byte    |  $-3.402E38 \sim 3.403E38$  |
| 双精度 double |    8 byte    | $-1.798E308 \sim 1.798E308$ |

> 【注】浮点型数据不适合出现在**不容许舍入误差**的金融计算领域，此时需使用``BigDecimal``类



#### 2.4.3 字符类型（char）

Java中所有字符都是用Unicode编码，故一个字符可以存储一个字母，一个汉字或其他书面语的一个字符。

字符变量表示的三种形式：

（1）使用单括号表示

（2）直接使用Unicode值表示，如：``\u0023``表示``#``

（3）使用转义字符表示制表符``\t``和换行符``\n``等

（4）使用ASCII值，其中48表示0，65表示A，97表示a



#### 2.4.4 布尔类型（boolean）

Java不允许使用0/1来表示false/true。

> boolean数据在内存中分配时使用int数据进行存储，用0/1表示。



### 2.5 变量的自动类型提升和强制类型转换

#### 2.5.1 变量的自动类型提升

规则：byte / short / char ----> int ----> long ----> float ----> double

（1）当容量小的变量与容量大的变量做运算时，结果自动转化为容量大的数据类型。（此处的**“容量”指的是表示数据范围的大小**）

> 【特殊情况1】byte、short、char各自或之间做运算时，结果应该用int保存。
>
> 【特殊情况2】当long类型的变量赋值时未添加“L”或“l”时，应该看作int类型朝long类型的类型提升。
>
> 【特殊情况3】浮点数未添加“F”或“f”时，应该看作double类型，此时不应该用float去接收。

（2）整型常量规定为int类型，浮点型常量规定为double类型。



#### 2.5.2 变量的强制类型转换

规则：如果需要将容量大的类型转换为容量小的类型，需要使用强制类型转换。

```java
long i1 = 1;
int i2 = i1;      // 编译失败
int i3 = (int)i1  // 编译成功
```

强制类型转换导致的精度损失：强制转换时实际上是把高位的数据阶段，**直接取原来低位的数据**作为新的数据进行存储。



### 2.6 String类的使用

String类使用**引用数据类型**，可以使用双引号的方式进行赋值。



#### 2.6.1 String和其他基本数据类型之间的运算

规则：

（1）String与其他数据类型之间只能做**连接**运算。

```java
String str1 = "abc";
boolean b1 = true;
int i = 10;
String str2 = str1 + b1 + i; // 编译通过
String str2 = b1 + i + str1; // 编译不通过，boolean和int之间不能做 + 运算
```

（2）不能将以String形式存储的纯数据，通过强制类型转化的方式，转化为int等类型。但是可以使用以下方法：

```java
String str1 = "100";
int num1 = Integer.parseInt(str1);
```



### 2.7 运算符

按照功能分类，可分为算数、赋值、比较、逻辑、位、条件、Lambda七种运算符。

按照操作数分类，可分为单目、双目、三目运算符



#### 2.7.1 算数运算符

（1）针对取余运算：若存在正负之间的取余运算，余数符号和被除数符号相同，余数绝对值等于被除数和除数的绝对值取余。

（2）自增和自减运算的特点：自增和自减运算不会改变变量的数据类型

```java
short i = 1;
// 若要对i进行加1运算：
i = (short)(i + 1); // 不使用++
i++; // 使用++
```



#### 2.7.2 赋值运算符

（1）赋值运算符可能会带有自动类型提升的功能

（2）支持连续赋值

（3）+= 、 -= 、 *= 、 /= 不会改变变量的数据类型



#### 2.7.3 比较（关系）运算符

（1）<、>、<=、>= 只适用于除了boolean之外的其他基本数据类型

（2）==、!= 可以适用于引用数据类型



#### 2.7.4 逻辑运算符

（1）逻辑运算符针对的时boolean变量

（2）&、| 表示逻辑与/或，&&、||表示短路与/或



#### 2.7.5 位运算符

| 运算符 | 运算       | 功能                                               |
| ------ | ---------- | -------------------------------------------------- |
| <<     | 左移       | 被移除的高位丢弃，空位补0                          |
| >>     | 右移       | 被移除的低位丢弃，空位补什么取决于原来最高位是什么 |
| >>>    | 无符号右移 | 被移除的低位丢弃，空位补0                          |
| &      | 与运算     | 按位取与                                           |
| \|     | 或运算     | 按位取或                                           |
| ^      | 异或运算   | 按位取异或                                         |
| ~      | 取反运算   | 按位取反                                           |



#### 2.7.6 条件运算符（三元运算符）

格式：

```txt
(条件表达式)?表达式1:表达式2 // 条件表达式为true则取表达式1，否则取表达式2
```



## 3. 流程控制语句

### 3.1 顺序结构

### 3.2 分支语句

#### 3.2.1 if-else结构

```java
if(条件判断){
	语句;
}
else if(条件判断){
	语句;
}
else{
	语句;
}
```



#### 3.2.2 switch-case选择结构

```java
switch(表达式){
	case 常量值1:
		语句;
        break;
    case 常量值2:
        语句；
        break;
    default:
        语句;
        break;
}
```

（1）若全都不加``break``，会导致匹配到某一个``case``后，后续``case``语句全都执行。

（2）``switch``中的表达式只能是特定的数据类型，包括：byte / short / char / int / 枚举（JDK5.0新增） / String（JDK7.0新增）。

（3）常量值不允许是条件表达式。

（4）default是可选的，可以放在任意位置。



### 3.3 循环结构

#### 3.3.1 for循环

```java
for(初始化条件;循环条件;迭代部分){
    循环体;
}
```

（1）循环条件部分必须是``boolean``类型变量或表达式

（2）迭代部分允许出现多条语句，多条语句之间使用``,``分割



#### 3.3.2 while循环

```java
初始化条件;
while(循环条件){
	迭代部分;
	循环体;
}
```



#### 3.3.3 do-while循环

```java
初始化条件;
do{
	循环体部分;
	迭代部分;
}while(循环条件)
```



### 3.4 break与continue的使用

| 关键字 |              适用范围              |     功能     |          相同点          |
| :----: | :--------------------------------: | :----------: | :----------------------: |
| break  | （1）switch-case结构 （2）循环结构 | 跳出当前循环 | 单独出现，后面不出现语句 |
| break  |              循环结构              | 跳出本次循环 | 单独出现，后面不出现语句 |



### 3.5 使用Scanner类获取键盘输入

步骤：

（1）导包``java.util.Scanner``

（2）创建Scanner类示例

（3）调用Scanner方法，获取变量

（4）调用``close()``方法，关闭资源

```java
import java.util.Scanner

class ScannerTest{
	public static void main(String[] args){
		Scanner scan = new Scanner(System.in);
		
        String name = scan.next();
		int age = scan.nextInt();
		double weight = scan.nextDouble();
		boolean isSingle = scan.nextBoolean();
		char gender = scan.next().charAt(0);
        
        scan.close();
	}
}
```



### 3.6 获取随机数

``random()``方法会返回一个``[0.0, 1.0)``范围的随机数。需求：获取``[a,b]``范围内的随机整数。

```java
import java.util.Scanner

class ScannerTest{
	public static void main(String[] args){
		int i = (int)(Math.random() * (b - a + 1) + a);
	}
}
```



## 4. IDEA相关设置

### 4.1 工程与模块管理

#### 4.1.1 IDEA项目结构

层级关系：project - module - package - class

在一个多module的项目之中，彼此module之间具有**互相依赖**的关系。



## 5. 数组

### 5.1 数组的概念

数组（Array）是多个相同类型的数据按一定顺序的集合，包括`数组名`、`下标`、`元素`、`数组长度`。



### 5.2 数组的特点

（1）数组本身是`引用数据类型`，但数组中存储的元素可以是任何数据类型。

（2）数组一旦初始化完成，长度就确定了，长度不可更改。

（3）创建数组对象会在内存中开辟一整块连续空间，占据的空间大小取决于数组长度和数组中元素的类型。



### 5.3 一维数组的使用

#### 5.3.1 声明和初始化

```java
        // 第一种方式：静态初始化，初始化时指明数组元素
        double[] prices = new double[]{1.0, 2.0, 3.0};

        // 第二种方式：动态初始化，指明数组长度
        String[] foods = new String[4];

        // 其他方式：
        int arr1[] = new int[4];

        int[] arr2 = {1, 2, 3, 4};
```



#### 5.3.2 元素的调用

数组下标的范围从 `0` 开始，到`数组长度-1`结束

```java
        arr1[0] = 1;
        System.out.println(arr1[0]);
```



#### 5.3.3 长度

使用`arr.length`

```java
        System.out.println(arr1.length);
```



#### 5.3.4 遍历

使用`for`循环遍历



#### 5.3.5 元素的默认初始化

（1）整型：`0`

（2）浮点型：`0.0`

（3）字符型：ASCII值为0对应的字符，即`\u0000`

（4）boolean型：`false`

（5）引用型：`null`



### 5.4 一维数组内存解析

Java将内存划分为五个区域：程序计数器、虚拟机栈、本地方法栈、堆、方法区

与目前数组有关的内存结构：

（1）虚拟机栈：用于存放方法中声明的局部变量，形式为`变量名：变量地址`

（2）堆：由于存放数组元素

```java
        // 两个变量指向同一个地址
        int[] a1 = new int[]{1, 2, 3};
        int[] a2 = a1;
        System.out.println(a2[1]); // 2
```



### 5.5 二维数组的使用

#### 5.5.1 声明和初始化

```java
        // 静态初始化
        int[][] arr1 = new int[][]{{1, 2}, {3, 4}};

        // 动态初始化方式1
        String[][] arr2 = new String[3][4];

        // 动态初始化方式2
        String[][] arr3 = new String[3][];

        // 其他写法：
        int arr4[][] = new int[][]{{1, 2}, {3, 4}};
        int[] arr5[] = new int[][]{{1, 2}, {3, 4}};
        int arr7[][] = {{1, 2}, {3, 4}}; //类型推断
```



#### 5.5.2 调用

仿照`5.3.2`



#### 5.5.3 长度

```java
        int[][] a = {{1, 2}, {3, 4, 5, 6}, {7, 8, 9}};
        System.out.println(a.length);    // 3
        System.out.println(a[0].length); // 2
        System.out.println(a[1].length); // 4
        System.out.println(a[2].length); // 3
```



#### 5.5.4 遍历

使用双层循环遍历。



#### 5.5.5 默认初始化

以动态初始化方式1：外层元素存储地址，内层元素参考`5.3.5`

以动态初始化方式2：外层元素存储null，内层元素报`空指针异常`



### 5.6 二维数组内存解析

仿照`5.4`和`5.5.5`



### 5.7 Arrays工具类

```java
        int[] a = new int[]{1, 2, 3};
        int[] b = {1, 2, 3};

        System.out.println(a == b); // 比较地址: false
        System.out.println(Arrays.equals(a, b)); // 比较依次元素值: true

        System.out.println(Arrays.toString(a)); // 显示元素值: [1, 2, 3]

        Arrays.fill(a, 4); // 使用指定值覆盖数组
        System.out.println(Arrays.toString(a)); // [4, 4, 4]

        int c[] = new int[]{1, 3, 2};
        Arrays.sort(c); // 直接调用快速排序
        System.out.println(Arrays.toString(c)); // [1, 2, 3]
        
        System.out.println(Arrays.binarySearch(c,2)); // 二分查找（原数组必须升序）: 1
```



### 5.8 数组常见异常

（1）角标越界：`ArrayIndexOutOfBoundsException`

（2）空指针：`NullPointerException`



























































